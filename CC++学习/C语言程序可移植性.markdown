程序移植性是程序员一定要有的概念。这一篇我总结一些经常需要考虑的点。

1. 大小端或者叫字节序。

    内存是按一个字节一个字节存储的，每个字节一个地址，那大于一个字节的数据怎么存储呢？这就有两种方式，大端模式或者小端模式。
    举例子，0x12345678在内存中怎么存？
    低地址→高地址
    大端模式：12 34 56 78
    小端模式：78 56 34 12
    总结出来的口诀就是：大端模式低地址存高字节，小端模式低地址存低字节。
    因为内存中存数据是先存由低地址到高地址所以大端模式符合人的大脑习惯，先写高位再写低位，小端模式低地址存低字节更符合cpu的习惯。x86的cpu一般是小端模式，ppc的cpu一般是大端模式，arm的两种模式都支持可以配置。
    网络传输协议都是按照大端模式，如果你的cpu是小端的那就需要转换。

2. 字长和数据类型

    int数据类型是几个字节？你答是四个字节？两个字节？都不完全对，在不同的操作系统下数据长度是不一样的，所以为了增强可移植性，一般都不用c语言自身的数据类型，而是重新定义自己的数据类型，如下，使用自己定义的数据类型，将来移植到不同平台时只需要根据不同平台增加对应的类型转换，不需要修改所有的源文件
    `type define u16 (short int)`
    `type define u32 (long)`

3. 数据对齐

    如果一个数据的内存地址是正好是他数据长度的整数倍，就叫自然对齐。例如一个4字节的数据的地址能够被4整除，就是自然对齐。看下面例子，定义下面的结构，a,b,c,d,都是自然对齐e就不是自然对齐。
```c
struct
{
    u32 a;
    u8 b;
    u8 c;
    u8 d;
    u16 e;
};
```

    不自然对齐对一些系统会导致cpu处理异常，或者降低处理器性能。所以上边的结构语言做调整，如下
```c
struct
{
    u32 a;
    u16 e;
    u8 b;
    u8 c;
    u8 d;
    u8 reserve[3]
}
```