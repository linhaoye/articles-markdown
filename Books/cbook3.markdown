# 3.C语言中的函数

函数是一种特殊的控制流程，只有理解函数调用的本质才能够更好地理解程序中的存储类别和模块化程序设计的思想。本章将详细介绍函数。

## 3.1函数的本质

函数的代码存储在内存中的代码段中，每个C语言程序都有一个代码段。下面实例给出了一个C语言函数和其翻译为汇编代码的形式。

说明：函数的本质是一段二进制可执行代码，这些代码是一些可以被机器直接执行的指令。

程序清单3-1  swap.c实现两个整数交换位置并且相加的函数
```c
int swap (int *a, int b)
{
    int tmp;
    tmp = *a;    /* 交换两个指针所指向的内容 */
    *a = *b
    b = tmp;    /* 交换两个变量的值 */
    return *a + *b; /* 返回二者的和 */
}
```

在翻译为汇编语言时，函数被翻译成为一段相对独立的汇编代码，并且使用函数名作为标号，表示此段代码的入口。当程序中需要调用该函数时，只需要跳转到这个标号处执行标号后面的函数代码就可以了。在内存中该函数机器指令的存储如图3-1所示。

由此可知，函数的本质是一段机器指令代码。而函数名的本质是一个标号，该标号的值等于内存中存储函数代码的内存空间的首地址。

函数在调用时会使进程空间中的栈不断增长，从当前进程空间中的栈项的位置到函数保存返回地址的位置，这块内存称为函数的栈帧。所有函数中定义的局部变量都存储在函数的栈帧上。当函数结束调用时该块栈帧就消失了，如图3-2所示。


图3-2函数的栈帧


## 3.2变量的作用域和生命期

C语言中每一个变量都有自己的作用域和生命期。作用域表示可以引用该变量的代码区域，生命期表示变量的存储空间所保存的时间。如果以变量的生命期来分类的话，C语言中的变量包括两种类型：一种是全局变量，一种是局部变量。本节将详细介绍变量的作用域和生命期。

### 3.2.1全局变量

全局变量也称为外部变量，这种变量是在函数外部定义的。因此它们不属于任何一个函数，而是属于一个源程序文件。其作用域从定义该变量的这一行开始，一直可以持续到定义该变量的源程序文件的结束。在该区间内所有的函数都可以引用该变量。

下面实例演示了一个全局变量的使用。该程序定义了一个全局变量，之后在两个函数中引用这个全局变量，并分别计算这个全局变量和函数参数的和，最后输出结果。

(1)在vi编辑器中编辑该程序。
程序清单3-2 global.c全局变量的使用
```c
#include <stdio.h>
int add(int a, int b)
{
    return a + b; /* 全局变量b打开作用域达不到这里，并不因位置关系，而是型参局部变量b覆盖了全局变量b，因此add()函数看不到全局变量b */
}

int b = 10; /* 定义一个全局变量b，以后人函数可以应用这个全局变量 */
int mul (int a)
{
    return a * b; /* 在mul()函数中引用全局变量 */
}

int main(void)
{
    int res2;
    res1 = add(1, 5);
    res2 = mul();

    printf("res1 : %d, res2 : %d", res1, res2);
    printf("the global b : %d\n", b); /* 在mian()函数在引用全局变量b */

    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc global.c -o global
```
(3)在shell中运行该程序。
```
res1 : 6, res2 : 10
the global b : 10
```

在全局变量b定义之前先定义了add()函数，因此add()函数不能引用这个全局变量。 如果希望在add()函数中也可以引用该变量，则需要在add()函数之前加上对全局变量b的声明，之后add()函数就可以引用该变量了。

### 3.2.2局部变量

局部变量也称为内部变量，其定义在函数或者复合语句的内部。其作用域仅限于函数或者复合语句内，离开该函数或者复合语句后就无法再引用该函数。

注意：定义在复合语句内部的变量同样是局部变量。

下面实例演示了局部变量的使用。该程序在复合语句内部定义了一个局部变量res，该局部变量在复合语句之外不能引用。因此在定义该变量的复合语句之外此变量就失效了。

(1)在vi编辑器中编辑该程序。
程序清单3-3  local.c演示使用局部变量
```c
#include <stdio.h>
int add(int a, int b)
{
    return a + b; /* add()函数内部不能引用main()函数在定义的局部变量 */
}

int main(void)
{
    int array[5]; /* 局部变量数组 */
    int i = 0;
    while (i < 5) {
        int res; /* res定义在复合语句内部，因此res也是一个局部变量，在复合语句之外不能引用 */
        res = add(i, 1); /* 对数组每个元素赋值 */
        array[i] = res; /* 将结果保存在数组 */
        i++;
    }
    for (i = 0; i < 5; i++)
        printf("array[%d] : %d\n", i+1, array[i]); /* 输出每一个数组单元 */

    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc local.c -o local

```

(3)在shell中执行该程序。
```
$./local
array[1] : 1
array[2] : 2
array[3] : 3
array[4] : 4
array[5] : 5
```
res是一个局部变量，在复合语句结束之后，变量res同样不能再被该函数中的其他语句所引用。也就是说res变量的作用域仅限于while语句的循环中。

说明：全局变量的生命期是整个程序，而局部变量的生命期仅在函数调用未结束之前有效。

因此，变量的作用域实际上是由变量的生命期来决定的，如图3-3所示。

(![])图片

图3-3变量生命期示意图


## 3.3变量的初始值

变量在定义之后要占用存储空间，如果未对变量进行初始化，这时变量中的值是多少呢？本节将介绍变量的初始值。

### 3.3.1全局变量的初始值

对于全局变量来说，如果一个全局变量未被初始化，其初始值由编译器自动设置为0。因此在使用一个全局变量时，不需要考虑其初值问题，直接使用就可以了。

下面实例演示了输出一个未初始化的全局变量的初始值。该程序定义了一个全局变量，但是未对其进行初始化。之后在程序中输出该变量的值，以观察该变量的初始值。

(1)在vi编辑器中编辑该程序。
程序清单3-4 uninit_global.c输出一个未初始化的全局变量的值
```c
#include <stdio.h>
int a; /*全局变量*/
int main (void)
{
    printf ("the global: %d\n", a);/*输出全局变量的值*/
    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc uninit_global.c -o uninit_global
```
(3)在shell中运行该程序。
```
$./uninit_global
the global : 0
```
### 3.3.2局部变量的初始值
局都变量存储在内存的堆栈中。定义了局部变量之后，编译器不会将其初始化为0，而是使用其占用的内存空间原有的值。这时的值是一个随机值，与本次程序无关，如图3-4所示。

因此，如果对局部变量不初始化就直接引用是很危险的。下面实例演示了这种危险的用法。该程序计算1~10之间整数的和。在main()函数中定义了一个局部变量sum，并使用它作为存储累加和的临时变量。

(1)在vi编辑器中编辑该程序。
程序清单3-5  sum.c累加1~10之间整数的和
```c
#include <stdio.h>
int main(void)
{
    int i;
    int sum; /* 定义一个全局变量，该全局变量作为一个累加和的临时值 */
    for (i = 1; i <= 10; i++)
        sum += i; /* 每次累加i */
    printf("the num is : %d\n", sum); /* 输出运行结果 */

    return 0;
}
```

图3-4函数栈帧占用内存空间示意图

(2)在shell中编译该程序。
```
$gcc sum.c -o sum
```
(3)在shell中运行该程序。
```
$./sum
the sum is : -10926734
```
程序执行之后的结果和预料的大相径庭。原因在于在使用sum作为累加和之前没有对sum进行初始化，所以sum的起始值并不是0，而是sum所在的存储单元中之前保存的一个无用值。这个值是随机的，可能是一个非常大的整数。这样的累加造成了sum变量溢出。

由此可知，对一个局部变量进行初始化是多么重要。

注意：如果不进行初始化，这种错误不仅无法避免，而且很难调试。

## 3.4与函数有关的优化

函数作为程序的一个重要组成部分，其优化作用是不容小视的。本节将介绍有关函数的优化。

### 3.4.1函数调用与程序优化
函数的作用是使代码模块性更强，利于代码的修改和阅读，并且可以有效地减小代码的体积。但是函数的调用通常很费时，一个函数调用的主要步骤有以下4步：

    1.函数调用需要将参数压入堆栈。
    2.函数调用需要保存寄存器的值。
    3.函数调用需要保存返回地址。
    4.函数调用会造成跳转。


以上4步操作中的前3个步骤都需要访问内存，而最后1步造成一次跳转。访问内存在计算机的操作中很消耗时间，如果每次调用函数都需要大量的时间访问内存，那么其执行速度慢是理所当然的。因此从这个角度来讲，函数可以说是一个时间换空间的例子。

说明：由于函数调用耗费时间，因此在程序执行过程中应当减少函数的调用，这样才能提高程序的执行速度。

下面实例演示了一个执行速度慢的程序。该程序调用3次func()函数，但是该函数每次返回的值都是一样的。

(1)在vi编辑器中编辑该程序。
程序清单3-6  slow.c -个多次调用函数，执行速度慢的程序
```c
#include <stdio.h>
int func(int a)
{
    return a + 1; /* 返回参数加1 */
}

int main (void)
{
    int res;
    res = func (1)  +  func(1) + func(1); /*多次调用函数，计算3次函数调用的结果*/
    printf("the result: %d\n",  res); /*输出变量*/

    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc slow.c -o slow
```
(3)在shell中运行该程序。
```
$./slow
the result : 6
```
该程序调用3次func()函数，每次该函数的返回值都是2，函数func()调用栈帧如图3-5所示。

图3-5 3次调用func()函数的栈帧

说明：由此可知，该程序调用3次func()函数完全没有必要，由于func()函数每次计算后的返回值都相同，因此只需要调用1次即可。

下面是一个改进版的函数调用程序。该程序只调用1次func()函数之后，将func()函数的返回值保存起来，用于后面的计算。

(1)在vi编辑器中编辑该程序。
 程序清单3-7 fast.c执行速度快的函数调用版本

 ```c
 #include <stdio.h> 
 int func(int a)
 {
    return a + 1; /* 返回参数加1 */
 }

 int main(void)
 {
    int res;

    res = 3 * func(1); /* 只调用一次func()函数，并使用函数的返回值进行乘法运算 */
    printf("the result : %d\n", res);  /* 输出结果 */

    return 0;
 }
 ```

(2)在shell中编译该程序。
```
$gcc fast.c -o fast
```
(3)在shell中运行该程序。
```
$./fast
the result : 6
```

可以看出，改进版的函数调用程序执行速度更快，设计思想也更合理。将多个运行结果相同的函数合并是一种合理的优化方法，但是这种优化方法的基础在于运行结果相同，而并不是简单的返回值相同。

注意：有时即使每次调用函数的返回值相同，但这种优化方法也是不能成立的。

下面实例演示了这种优化方面的错误。
(1)在vi编辑器中编辑该程序。
程序清单3-8 optim.c合并多次返回值相同的函数调用出错
```c
#include <stdio.h>
int count = 0;
int func (int a);
{
    count ++; /* func函数内部操作 */
    return a + 1; /* 返回参数加1 */
}

int main(void)
{
    int res;

    res = 3 * func(1); /* 只调用一次func()函数，并使用函数的返回值进行乘法运算 */

    printf("the count : %d\n", count); /* 输出全局变量的值 */
    printf("the result : %d\n", res); /* 输出函数返回的和 */

    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc optim.c -o optim
```
(3)在shell中运行该程序。
```
$./optim
the count : 1
the result : 6
```

由于func()函数只调用了1次，所以全局变量count只累加了1次，其值为1。如果不做优化，将"3*func(1);"展开为"func(1)+func(1)+func(1)"，这时count的值应当是3，而不是1。因此合并多个函数的前提条件是每个函数的运行结果一样，而不是简单的返回值一样。

### 3.4.2变量存储优化

C语言程序中的局部变量存储在栈上，而全局变量存储在数据段上。由于二者存储位置的不同导致了二者生命期的不同。

注意：全局变量的生命期是整个程序，而局部变量的生命期仅在定义局部变量的函数结束调用后就结束了。

对于在程序中调用频率很高的局部变量，编译器会自动将其存储在寄存器中，但是全局变量不会存储在寄存器中。因为全局变量需要在整个程序运行的逆程中一直存在，如果全局变量存储在寄存器中的话，那么在整个程序的执行过程中，该寄存器都将无法存储临时变量或者中间值了。这对于寄存器资源稀少的计算机来说是不能接受的，程序的运行效率也会大打折扣。

因此全局变量一定存储在数据段上，也就是存储在内存中。这一点很重要，因为计算过程中访问内存的时间要远超过CPU的计算时间。所以尽量减少内存的访问是一个提高程序执行速度的好方法。下面演示了一个这样的实例，对比程序清单3-9和程序清单3-10，比较一下这两个代码片段的执行速度。下面程序使用一个全局变量作为循环算子，在函数f()内部执行一个循环。该循环共循环100次，每次循环需要访问全局变量i。

程序清单3-9 global.c使用全局变量作为循环算子
```c
int i; /*全局变量作为循环因子 */

void f()
{
    int a[10];
    for (i = 0; i<100; i++) /*将数值赋值到数组中*/
        a[i] = i;
}
```

下面程序使用一个局部变量作为循环算子，在函数f()内部执行一个循环。该循环同样循环100次，每次访问局部变量i。

程序清单3-10  local.c使用局部变量作为循环算子
```c
void f()
{
    int i;          /*局部变量作为循环因子 */
    for(i=0; i<100; i++)
        a[i] = i;   /*将数值赋值到数组中*/
}
```

程序清单3-9的代码中循环算子i是一个全局变量，全局变量存储在内存上。因此每次访问该全局变量时需要访问内存数据，如图3-6所示。

(![])图

图3-6访问一个作为循环因子的全局变量

在程序清单3-10的代码中循环算子i是一个局部变量，对于这种高频率使用的局部变量编译器会自动将其存储在寄存器中。因此每次访问这个局部变量时实际上是在做一个寄存器访问。

对比两个代码的执行流程，不难发现程序清单3-9中每次循环需要做以下3步操作。

(1)从内存单元中读取变量i的值。
(2)对变量i进行累加。
(3)将累加后的i的值存储到内存中。

而在程序清单3-10中每次循环只需要l步，那就是累加变量i所在的寄存器的值。由此可知，程序清单3-9的执行效率远不及程序清单3-10的执行效率。因此在编程过程中，不要将循环算子等高频率使用的变量设置为全局变量或者静态变量。

## 3.5编写多文件程序——变量的存储类别

当一个程序很大时不能将所有的代码都书写在一个源文件中，这样做会严重破坏程序的模块化，使程序变得难以维护。因此这个时候需要将源程序代码书写在多个源文件中。

### 3.5.1存储类别

auto: 自动变量，默认的存储类别，根据变量定义的位置决定变量的生命期和作用域。如果变量定义在任何一个函数的外面，该变量就是一个全局变量。如果定义在函数的内部，则该变量是局部变量。在C语言中，如果忽略变量的存储类别，编译器会认为该变量的存储类别为auto。这时编译器会自动为用户决走该变量应当存储的位置和性质。

register: 寄存器变量，此类别的变量会被优先分配寄存器。通常作为循环因子的变量会被分配寄存器。

extern: 外部变量（全局变量），该关键字用来扩展全局变量的作用域，扩展的范围是从使用extern变量出现开始到该文件结束。由于全局变量不像局部变量那样会因为栈帧的消失而消失。所以extem关键字所做的工作只是让其他文件中的程序可以引用该变量，并不改变该变量的生命期。

static: 静态变量，用于限制作用域，这种变量存储在数据段上，无论该变量是全局变量还是局部变量。静态全局变量的作用域仅限于该文件，而静态局部变量的作用域仅在其定义所在的复合语句内。对于静态局部变量而言，static关键字可以改变其生命期，而对静态全局变量则不能。

### 3.5.2 static变量的作用——改变变量的生命期

说明：static关键字的作用之一就是可以改变变量的作用域和生命期。

对于一个存储类别声明为static的全局变量而言，其生命期并没有发生改变，在整个程序执行过程中该变量一直存在。但其作用域反而有所减小，只有本文件的函数可以引用该全局变量。

对于一个存储类别声明为static的局部变量而言，其作用域没有改变，只有定义该局部变量的函数可以引用该变量。但是其生命期发生了变化，在整个程序执行期间，该变量都存在。

下面实例演示了使用static局部变量。该程序打开若干个文件并且将文件的内容输出到屏幕上，每输出5行就会输出1个空行。

(1)在vi编辑器中编辑该程序。

程序清单3-11 static_local.c打开文件输出文件内容
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX 1024

int output(char * file_name)
{
    FILE *fp;
    char buf[MAX];

    static int count = 0; /* 静态局部变量，保存输出的行数 */
    fp = fopen(file_name, "r");/* 打开文件 */
    if (fp == NULL) {
        perror("fail to open");
        return -1;
    }
    while(fgets(fp, buf MAX) != NULL) {/* 每次读入文件的一行 */
        n = strlen(buf);
        buf[n-1] = '\0';
        printf("%s\n", buf); /* 输出读入的一行 */

        /* 累加count，如果count能被5整除，则输出换行 */
        if (count ++ % s == 0)  printf("\n");
    }

    fclose(fp);
    return 0;
}

int main(void)
{
    char file_name[][10] = {
        "test.txt",
        "test1.txt",
        "test2.txt"
    };

    int i;
    i = 0;
    while (i < 3) {
        if (output(file_name[i]) == -1) /* 输出每一个文件的内容 */
            exit(1);
        i++;
    }   

    return 0;
}

```
(2)在shell中编译该程序。
```
$gcc static_local.c -o static_local
```
(3)使用cat命令查看test.txt文件的内容。
```
$cat test.txt
hello world
hi beijing
```
(4)使用cat命令查看testl.txt文件的内容。
```
$cat test1.txt
this is a8 test
no warning
have fun
```
(5)使用cat命令查看test2.txt文件的内容。
```
$cat test2.txt
linux is great
what a game
happy coding
GNU is not unix
linux is not unix, too
```
(6)在shell中运行该程序。
```
$./static_local

```
注意：如果将局部变量count的存储类别设置为非static，每个文件输出行数的累加就不会被保存了。

用户也可以使用全局变量的方法代替使用static局部变量，但这样做就不能保证模块中的其他函数不会因为误操作而修改该变量的值。因此，使用static局部变量还是很有必要的。

### 3.5.3 static变量的作用——实现封装和模块化设计

说明：static变量的另一个显著作用就是可以实现一个模块的封装。

static存储类别的特性决定了使用static关键字声明的全局变量，只有本文件内的函数可以引用，因此在C语言中一个源程序文件就是一个模块。当用户在一个文件中定义了一个static全局变量后，其他文件（模块）只能通过该模块提供的接口函数来访问这个static全局变量，而不能直接对其进行操作。

下面实例演示了一个链表模块的实现。该模块中定义了一个链表头结点指针head，head指针被定义为static全局变量。该模块同时定义了链表的一般性操作函数。这些操作函数可以操作该链表，而该模块外的函数不能直接操作head指针，只能通过调用模块中定义好的链表操作函数来操作head指针和整个链表。链表操作函数实现如下。

程序清单3-12  list.c实现一个链表操作模块
```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node * Node; /* 自定义结点指针类型 */
static Node head; /* 链表头 */

/*
 * 链表结点结构
 * val：结点的值
 * next：下一个结点的指针
 */

struct  node f
    int val;
    Node next;
};

/* 插入结点函数 */
int insert(int val)
{
    Node p, q;
    p= head;
    if(p!=NULL){ /*链表非空*/
        while (p->next != NUIL) {
            p= p->next;
        }
    }

    q = (Node) malloc (sizeof (struct  node)); /* 创建一个新的结点 */
    if (q == NULL)
        return -1;

    q->next=NULl;    /* 对结点赋值 */
    q->val=val;
    if(p==NULL){ /*空链表事*/
        head=q;
        return 1;
    )

    p->next = q; /* 结点链入链表 */
    return 1；
)
/* 遍历链表，打印每个结点的值 */

void print()
{
    Node p = head;

    while (p != NULL) { /* 输出每个结点的值 */
        printf("%d\n", p->val);
        p = p->next;
    }
}

/* 遍历链表，释放每一个结点 */
void destroy()
{
    Node p = head;
    while (p != NULL) { /* 遍历链表 */
        Node q;
        q = p;
        p = p->next; /* 到下一个结点 */
        free(q);     /* 释放该结点 */
    }
    head = NULL;     /* 清空链表的头指针 */
}

```

这样做就实现了这个链表操作对外界的封装。程序中其他模块不用了解链表的操作是如何进行的，只需要使用模块中提供的接口函数就可以了。同样，如果用户企图不按照规则操作链表也是不可能的，因为如果用户除了使用接口函数之外就不能操作链表。因此整个链表操作模块就完全独立于其他模块了，如图3-7所示。

(![])图


图3-7程序中其他函数操作链表

最后一步就是向外界提供一个链表操作模块的接口函数声明，这些函数的声明包含在list.h中。

程序清单3-13  list.h链表操作函数的接口声明
```c
extern int insert (int val);
extern void print();
extern void destroy();
```

说明：由于模块实现的细节对外部模块来讲是未知的，因此这时修改链表操作并不影响使用该模块用户的其他代码。

假设用户使用链表操作模块的代码如下。

程序清单3-14  main.c用户使用链表操作接口函数
```c
#include <stdlib.h>
#include "list.h"

int main (void)
{
    int i;
    for (i=0; i < 5; i++)  /* 使用insert()函数插入5个结点。*/
        if (insert (i) == -1)
            exit (1);
    print();    /* 输出链表的所有结点 */
    destroy();    /* 销毁链表 */
    return 0；
}
```

如果将链表操作函数中insert()修改，只要不修改函数的接口，用户程序的代码就不会改变。但是如果修改了函数接口，用户的代码就要做很大改动了。

注意：因此在修改模块的时候，修改函数接口本身是一个大忌。

## 3.6编写多文件的程序——链接的作用
当一个多个文件的程序编译结束后，需要由链接器将这些独立的模块链接为一个整体的可执行程序。本节将详细介绍链接的过程。

### 3.6.1链接多个文件

为了使程序的模块化更强，代码更易于分类管理，有时需要将同类型的代码存储在一个文件中。这时每一个文件代表着一类函数代码。这些代码使用同样的资源，完成同样的操作。由于代码被划分为若干个模块，这时就会导致多个C语言文件（模块）链接的问题。

说明：在一个文件中很可能需要引用另一个文伴中定义的全局变量或者函数。

下面实例演示了一个简单的数组操作程序。这个程序计算数组中所有元素的和，可以得到数组中最大的元素，可以遍历输出数组。这些操作均实现为函数。由于这些函数都是用来操作数组的，因此属于同一类型的操作，这些函数被实现在一个operate.c文件中。目标数组使用一个全局变量来实现，同样定义在operate.c文件中。Main()函数定义在main.c文件中，该函数需要引用operate.c文件中的函数和变量。

(1)在vi编辑器中编辑该程序。

程序清单3-15 operate.c操作数组的函数定义
```c
#include <stdio.h>
#define MAX 5
int array[MAX] = {2,7,6,4,8,};

/* 计算数组中所有元素的和 */

int sum()
{
    int i;
    int n; /* 临时变量 */
    n = 0;
    for (i = 0; i < MAX; i++) /* 遍历数组，素加每个数组元素，计算数组所有元素的和 */
        n += array[i];

    return n;
}

/* 行到数组中最大的元素 */
int get_max()
{
    int max;
    int i;
    i = 0;
    max = array(i);
    for (i = 0; i < MAX; i++)　/* 遍历数组，比较每个元素，得到数组中最大的元素 */
        if (array[i] > max)
            max = array[i]; /* 找到最大值 */
    return max;
}

/* 输出数组中每个元素的值 */
void print()
{
    int i; /* 临时变量，作为循环因子 */
    for (i = 0; i < MAX; i++) /* 遍历数组，输出数组中每个元素的值 */
        printf("array[%d] : %d\n", i + 1, array[i]);
}

```

该程序的main()函数定义在maln.c文件中。

程序清单3-16  main.c定义main函数
```c
#include <stdio.h>
extern int array[];
extern int sum();
extern int get_max();
extern void print();

int main(void)
{
    int all, max; /* 最大值 */
    all = sum();
    max = get_max(); /* 得到最大值 */
    print(); /* 打印数组元素 */
    printf("the sum : %d, the max: %d\n", all, max); /* 输出结果  */

    return ;
}
```

(2)在shell中编译该程序如下。
```
$gcc main.c operate.c -o main
```

(3)在shell中运行该程序如下。
```
$./main
array[1] : 2
array[2] : 7  
array[3] : 6  
array[4] : 4  
array[5] : 8  
the sum : 27, the max
```

### 3.6.2链接时符号解析规则

在使用多文件编译时要特别注意变量的引用和符号解析问题。

注意：开发人员一定要了解多个文件中各种符号的解析规则。

在介绍C语言的符号解析规则之前，首先解释两个主要的概念——声明和定义。声明表示告知编译器该变量的存在，此时是不为该变量分配存储空间的，如下所示。

而定义变量时不仅告知编译器该变量的存在，而且为该变量赋值。由于需要赋值，这时该变量的存储空间就被分配了，如下所示。

```c
int a = 1;
```

当该变量的作用域范围内只有声明，而没有该变量的定义时，编译器会自动将第一个声明认为是变量的定义，如下所示。
```c
int f (int a)
{
    /**
     * 在这里声明变量b，由于在该函数没找不到对变量b的定义。
     * 因此声明被认为是变量的定义，这时分配了4个字节存储空间b
     */
    int b;
    b = 2; /* 这里是针对变量b的赋值，不是定义 */
    return a + b;
}
```

C语言中的符号解析规则如下。
    1.不允许有多个符号的定义，这里的符号指的是变量或者函数。
    2.如果有一个符号定义和多个符号的声明，则选择被定义的符号。
    3.如果有多个符号的声明，则从其中任选一个作为符号的定义。

### 3.6.3链接规则的应用

根据3.6.2节介绍的链接规则，判断当使用下面各例中的文件进行链接的时候，在进行符号解析时可能发生的问题。

实例1：a.c包含一个main()函数的定义。
```c
int main(void)
{
    printf("hello world"); /* 输出一行信息 */

    return 0;
}
```

b.c中也包含一个main()函数的定义。
```c
int main(void)
{
    printf("bye8-bye\n"); /* 输出一行信息 */
    return 0;
}
```

注意：该例会造成链接错误，原因是两个文件中都对一个函数进行了定义。这种现象违反了规则1。

实例2：a.c中包含一个全局变量a的定义。
```c
int a = 123; /* 一个全局变量 */
int main(void)
{
    return 0;
}
```

b.c中也包含一个全局变量a的定义。
```c
int a = 121; /* 同名的全局变量 */
void f(void)
{
    printf("function f\n");
}
```

注意：该例会造成链接错误，原因是两个文件中都对一个变量进行了定义。这种现象同样违反了规则1。

实例3：a.c中包括一个全局变量a的定义。
```c
#include <stdio.h>
void f(void); /* 函数声明 */
int a = 123;  /* 全局变量的定义 */
int main(void)
{
    f();      /* 调用函数 */
    printf("a=%d\n", a); /* 输出全局变量 */
    return 0;
}
```

b.c中包含一个全局变量a的声明。
```c
int a;      /* 全局变量的声明 */
void f()
{
    a = 121; /* 对全局变量赋值 */
}
```

(1)在shell下编译该程序，该例不会造成链接错误。
```
$gcc a.c b.c -o app
```
(2)在shell下运行该程序。
```
$./app
a = 121
```

由于两个源文件中出现了对变量a的定义和声明，因此其符号解析符合解析规则2--当出现一个变量定义和多个变量声明的时候应当选择变量的定义。所以全局变量a在函数f()中被修改为121，这个结果被保存到全局变量a的存储空间中。

实例4：a.c中包括一个全局变量a的声明。
```
int f(void); /* 函数的声明 */
int a; /* 全局变量的声明 */
int main(void)
{
    a = 123;
    f(); /* 调用函数 */
    printf("a=%d\n", a);

    return 0;
}
```

b.c中也包含一个全局变量a的声明。
```c
int a;  /* 全局变量的声明 */
void f()
{
    a = 121; /* 对全局变量的赋值 */
}
```

(1)在shell下编译该程序，该例不会造成链接错误。
```
$gcc a.c b.c -o app
```

(2)在shell下运行该程序。
```
$./app
a = 121
```

由于两个文件中都含有对全局变量a的声明，因此根据符号解析规则3，编译器会选择最先扫描到的那个声明作为变量的定义。无论编译器选定哪一个符号，其都不会对程序的本质造成影响。该程序的情况和实例3类似。

实例5：a.c中包含全局变量a的定义。
```c
#include <stdio.h>
int a = 123; /* 合局变量的定义 */
int b = 121;
int main(void)
{
    f(); /* 调用函数f */
    printf("a = %d, b = %d\n", a, b); /* 输出变量a,b */
    return 0;
}
```

b.c包含对全局变量a的声明。
```c
double a;    /* 变量声明 */
void f()
{
    a = 0.0;   /* 对变量a赋值 */
}
```

(1)在shell下编译该程序，该例不会造成链接错误。
```
$gcc a.c b.c -o app
```

(2)在shell下运行该程序。
```
$./app
a = 0, b = 0
```

两个源文件包含全局变量a的定义和全局变量a的声明。根据符号解析规则2不会造成链接错误，编译器会选择符号定义。这时b.c中函数f()内对变量a的操作实际上操作的是a.c中的全局变量a。所不同的是由于在b.c中声明的变量为双精度型，所以对该变量进行赋值为0.0时，需要将由a所指向的内存空间的首地址开始的8个字节清0，而不是4个。这个时候，变量a后面的变量b的存储空间也被覆盖了，如图3-8所示。

图3-8变量a和变量b的存储示意图

因此输出a和b的值都是0。由此可以了解C语言中符号的解析规则是很重要的。许多不了解内情的开发者通常会弄不清楚遮个问题，因而不知错误的真正原因。

## 3.7可变参数

可变参数是C语言中一个比较高级的应用，使用可变参数后，用户可以在调用函数时再确定该函数所需要的参数。

### 3.7.1可变参数的概念

C语言中支持参数可变的函数，在编程过程中经常使用的输出函数printf()就是一个典型的参数可变的函数，其函数原型如下。

```c
#include <stdio.h>
int printf(const char* format,  ...);
```

printf()函数是一个可变参数的函数，其参数数目在函数调用的时候确定。

注意：该函数至少有一个参数，之后的参数是可有可无的。

printf()函数的原型中第1个参数format是固定的，后面的参数个数和类型都是可变的。编译器使用3个点"..."作为参数的占位符，告知编译器第1个参数format的后面还可能会有若干的参数。

可变参数的函数在实际调用时确定其实际的参数个数，以printf()函数举例，其调用形式如下：
```c
int num = 0;
char *p ="hello world\n";  /* 字符串p */
printf("%d＼n", num);      /* 输出数字*/
printf("%s\n", str);       /* 输出字符串 */
printf("the number is %d,  the string is:%s\n", num, str);
```

第3行的printf()函数调用包括2个参数。第1个参数是一个字符串，这个字符串是每一个printf()函数必须包括的；第2个参数是一个整型变量，表示需要输出的整型变量的僮。第4行的printf()函数调用也包括2个参数，但第2个参数不是一个整型变量，而是一个字符串的首地址，其类型为指针。

第5行的printf()函数调用包括了3个函数，第1个参数仍然是一个字符串的首地址，后面2个参数分别是整型和地址型。因此可变参数的函数个数和类型都是在函数调用的时候才确定的。虽然参数可变，但是这种函数必须包含1个参数，且这第1个参数的类型在定义的时候就已经确定。

注意：后面的所有可变的参数都是以此参数为基点的。

### 3.7.2实现一个简单的可变参数的函数

了解了可变参数的函数概念之后，下面通过实现一个可变目标的函数给读者一个更直观的印象，为后面讲解可变目标函数的实现做好准备。下面示例演示了一个可变目标参数的实例。该程序调用一个可变参数的函数，这个函数输出所有的参数。

(1)在vi编辑器中编辑该程序。

程序清单3-17 print_args.c列出所有的参数
```c
#include  <stdio.h>
#include  <stdarg.h>

/*可变参数函数，其中第一个参数的类型是固定的，在定义的时候必须已经定义好 */
int print_args (int begin, ...) 
{
    va_list ap;
    char *p;
    int n;

    va_start(ap, begin);
    p = va_arg(ap, char*);
    n = 0;
    while (p != NULL) { /* 可变参数以NULL结尾，在遇到NULL结束符之前输出所有参数 */
        n++;
        printf("arg %d: %s\n", n, p); /* 输出每个参数 */
        p = va_arg(ap, char*); /* 得到下一个参数 */
    }
    va_end(ap);

    return n;
}

int main(void)
{
    int n;
    n = print_args(-1, "hello", "world", NULL); //第一次调用，使用4个参数

    printf("first, without NULL:%d\n", n);
    n = print_args(-1, "China", "beijing", "Olympic", NULL); /* 第二次调用，使用5个参数 */

    printf("second, without NULL:%d\n", n);
    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc print_args.c -o print_args
```
(3)在shell中运行该程序。
```
```

下面对print_args()函数实现的关键点做一下解释。

1.标准头文件stdarg.h：这个头文件中定义了一系列的宏来处理这个可变长度的参数列表。如果需要实现一个可变参数的函数，该头文件是必不可少的。

2.类型va_list：这个类型定义在stdarg.h头文件中。va_list定义为这样一个数据类型，循环使用且每次指向一个可变的参数。因此该类型的变量代表整个参数的列表。在上例中定义变量ap为va list类型的变量，所以ap代表整个参数列表。

3.宏va_start: va_stat宏初始化一个va_list类型的变量（上例中使用变量ap），使其指向第1个可变的参数。经过初始化后，变量ap就可以代表整个参数列表了，因此该宏必须在使用参数列表之前使用。每个可变参数的函数的第1个参数必须固定，否则无法进行初始化，并且将变量ap指向该参数列表。

4.宏va_arg: va_arg宏返回一个可变长度参数的值并使ap指向下一个可变的参数，该宏使用一个类型名来确定要返回的类型和指针ap需要移动的字节单位。

5.宏va_end:做一些必要的清理工作，需要在程序结束前使用。

通过分析以上实例的关键点代码，可以总结一个可变参数的函数实现流程如下：

    (1)使用va_start宏初始化va_list类型的变量，使其指向可变参数列表的头。
    (2)使用va_arg宏得到每一个参数并对其进行处理，当遇到一个结束标志时停止处理。
    (3)使用va_end宏做清理工作。

将这3个步骤使用流程图表示如图3-9所示。

### 3.7.3可变参数实例

图3-9使用可变参数的流程

本节介绍一个可变函数的实现实例my_printf()函数。printf()函数使用可变参数的方法实现，并且对my_printf()函数的第1个参数format进行字符串处理即可。

(1)在vi编辑器中编辑该程序。
程序清单3-18 my_printf.c使用可变参数实现一个简单的printf()函数
```c
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#define MAX 64

/*
 *
 * 将一个short型变量转换为字符串形式成功返回转挨后的字符串首地址，失败返回NULL
 * i : 需要转换的短整型，最大值为65536，不处理负数的形式
 * p : 转换后的字符串的首地址。p代表存储该串的数组空间的起始地址
 */
char * itoa(int i, char *p)
{
    char *q;
    if (p == NULL) return NULL;

    p[0] = (i / 10000) + '0'; /* 将整数转换为数字，整型的最大值不会超过65536，且不处理负数 */

    i = i % 10000;
    p[1] = (i / 1000) + '0';
    i = i % 1000;
    p[2] = (i / 100) + '0';
    i = i % 100;
    p[3] = (i / 10) + '0';
    p[4] = i + '0';
    p[5] = '\0';

    /* 下面的操作用于去除多个0，将第一个有效数字作为第一个数字 */
    while (*q != '\0' && *q == '0') /* 找到第一个非0的数字 */
        q++;
    if (*q != '\0')
        strcpy(p, q);　/* 将0后面的数字移动到缓冲区的首地址处 */

    return p;
}

/**
 * 自定义的printf()函数，这是一个可变参数的函数。第一个参数固定为字符串指针型。
 * 返回值是实际输出的字符数
 */
int my_printf(const char *format, ...)
{
    va_list ap;
    char c, ch;
    int i;
    char *p;
    char buf[MAX]; /* 保存字符串的缓冲区 */
    int n = 0; /* 累计输出的字符数 */
    va_start(ap, format); /* 到达可变参数的超始位置 */
    c = * format;
    while(c != '\0') {
        if (c == '%') { /* 使用'%'进行转义，跳过'%'字符，处理后面的转义字符 */
            format++;

            c = * format;
            switch (c) {
                case 'c': /* 处理字符 */
                    ch = va_arg(ap, int); /* 取得第一个字符参数 */
                    putchar(ch);　/* 输出该字符 */
                    n++;
                    break;
                case 'd': /* 处理整数short */
                    i =va_arg(ap, int); /* 取该整数参数 */
                    itoa(i, buf); /* 将整数转换为字符串 */
                    n += strlen(buf); /* 累计输出字符数 */
                    fputs(buf, stdout); /* 输出整数的字符串形式 */
                    break;
                case 's':
                    p = va_arg(ap, char *); /* 取下一个指针参数，保存字符串的首地址 */
                    n += strlen(p);
                    fputs(p, stdout); /* 输出该字符串 */
            }
        } else {
            putchar(c); /* 普通字符，则输出该字符 */
            n++;
        }
        format++; /* 处理下一个字符 */
        c = *format;
    }
    va_end(ap); /* 做一些清理工作 */
    return n; /* 返回实际的输出字符数 */
}

int main(void)
{
    /* 调用my_print()函数输出字符、整数和字符串 */
    my_printf("the char is : %c\n, the number is : %d\n, the string is : %s\n", 'a', 100, "hello world\n");

    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc my_printf.c -o my_printf
```
(3)在shell中运行该程序。
```
$./my_printf
the char is : a
the number is : 100
the string is : hello world
```

该程序中调用两个函数，一个是my_printf()函数，一个是itoa()函数。

说明：其中itoa()函数用于将一个整型转换为字符串。

该函数首先提取整数的各个位，并将其转换为字符。最后需要将该字符串前面的若干个0去掉，其实现流程如图3-10所示。

my_printf()函数是一个可变参数的函数，首先使用va_start宏进行初始化，之后处理format字符串所表示的每一个字符。如果遇到%’字符表示这个字符后面是一个转义字符，需要使用va_arg宏得到一个可变参数，并且对其进行适当的处理。my_printf()函数是一个简单的版本，只处理'c'、'd'和's'的情况。

图3-10 itoa()函数的执行流程

对于'c'的情况，my_printf()函数只需要输出一个字符即可；对于"的情况，需要将参数中的整型转换为字符串后输出，因此需要调用itoa0函数，之后输出转换好的字符串即可；对于's'的情况，直接将参数所表示的字符串输出即可。

说明：由于format参数所表示的字符串中带有\0'结束符，因此当处理到'\0'的时候循环就结束了。

在my_printf()函数退出之前使用va_end宏进行清理工作，并且返回实际输出的字符数。 整个my_printf()函数的执行流程如图3-11所示。

图3-11  my_printf()函数的执行流程

输出整型数据的流程图如图3-12所示。

输出一个字符和输出一个字符串的流程相同，如图3-13所示。

图3-12输出整型数据的流程图

图3-13输出一个字符串和一个字符的流程图

### 3.7.4关于printf()函数的疑问——缺少整型参数

说明：错误地使用printf()函数会出现一些问题，这些问题有时会输出一些莫名其妙的东西。

现在读者根据printf()函数的实现方式，可以通过分析可变参数的原理来理解这些错误出现的原因。

一个典型的错误是在输出整型数据的时候缺少要输出的整型变量，如下所示。
```c
printf("%d");
```
这种写法本身是错误的，用户需要输出一个整型数据，但是却没有指定整型数据的参数。为了验证该语句的输出结果，需要读者自己编写一个验证程序。

(1)在vi中编辑程序如下。
程序清单3-19  err_int.c错误的printf()函数用法
```c
#include <stdio.h>
int main(void)
{
    printf("%d\n"); /* 输出一个整型，但是缺少整型参数 */
    return 0;
}
```

(2)在shell中编诨该程序。
```
$gcc err_int.c -o err_int
```
(3)在shell中运行该程序。
```
$./err_int
-1067345
```

该程序输出了一个值，也就是说即使没有指定要输出的整型数据，printf()函数仍然会输出一个数据。现在的问题是这个输出的数字是什么呢？printf()函数使用可变参数来实现，其原理是从第1个参数（format字符串）开始，每次向后取一个参数作为格式化输出的数据。因此正常的printf()函数调用如下。

```c
int a;
printf("%s\n", a); /* 正确的写法 */
```

printf()函数内部的可变参数示意图如图3-14所示。

图3-15错误的可变参数的存储示意图

### 3.7.5关于printf()函数的疑问——缺少字符串地址参数

另一个典型的实例就是在输出字符串时，缺少字符串地址的参数，如下所示。
```c
printf("%s\n");
```

这种写法本身是错误的，用户需要输出一个字符串型数据，但是却没有指定字符串型数据的参数。为了验证该语句的输出结果，需要读者自己编写一个验证程序。

(1)在vi中编辑程序如下。
程序清单3-20  err_str.c错误的printf()函数用法
```c
#include <stdio.h>
int main(void)
{
    printf("%s\n"); /* 输出一个字符串，但是缺少字符串参数 */
    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc err_str.c -o err_str
```
(3)在shell中运行该程序。
```
$./err_str
Segmentation fault
```

执行程序之后程序出现了段错误，道理同上一个例子。printf()函数将第1个参数format字符串地址后面的4个字节，作为用户需要输出的字符串的首地址，因此正常的printf()函数调用如下。
```c
char *p = "hello";
printf("%s\n", p); /* 正确的写法 */
```

printf()函数内部的可变参数的示意图如图3-16所示。

图3-16可变参数的存储示意图

注意：对于错误的printf()函数来说，虽然用户没有将一个指针存储在format字符串的地址后面，但是printf()函数根据流程，还是把存储format字符串地址后面的4个字节的内容，当作用户传入的字符串首地址，并且寻找其所表示的存储空间的内容。但是这块存储空间并不一定是可访问的，因此出现了段错误，如图3-17所示。

# 第4章  C语言中的指针与字符串

指针是C语言的特色之一。可以说不能熟练地使用指针，就不能算是一个合格的C语言程序员。本章将详细讲解指针的相关操作。

## 4.1sizeof运算符

sizeof运算符是C语言中的关键字，用于求一个对象所占用的字节数。使用sizeof运算符计算对象的大小是一个良好的编程习惯。

### 4.1.1 sizeof运算符的应用——得到内置类型的大小

有时候一些内置类型的大小会随着体系结构的不同而不同。最典型的就是长整型(long)数据，在32位体系结构的CPU中，该类型占用4个字节。在64位体系结构的CPU ，该类型则占用8个字节。因此使用sizeof运算符可以屏蔽此细节，使代码具有更好的移植性。下面实例演示了计算每种内置类型所占用的字节数。该程序使用sizeof关键字计算每种类型的变量所占用的字节数。

(1)在vi编辑器中编辑该程序。

程序清单4-1  type.c测试内置类型的大小
```c
#include <stdio.h>
int main (void)
{
    return 0;
}
```