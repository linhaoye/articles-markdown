# 第2章 控制结构

控制结构是C语言的基础，熟练掌握控制结构是掌握C语言的基石。本章主要介绍控制结构的相关知识。

## 2.1 goto语句

在以前的C语言教科书中，goto语句都是被禁止使用的，原因是这样做可能会破坏控制流程。但是活用goto语句可以增强程序的控制。本节将主要介绍goto语句。

### 2.1.1 C语言中的无条件跳转

goto语句实现C语言中的无条件跳转，使用goto语句可以跳到一个指定的标号处进行执行。如下面实例所示，该程序中定义一个标号end，在打印提示信息后使用goto语句跳过hello world信息的输出而直接打印退出信息。

程序清单2-1 goto.c 使用goto语句实现无条件跳转

```c
#include <stdio.h>

int main(void)
{
    printf("The begin\n");
    goto end;                   /* 使用goto语句实现跳转 */
    printf("helle world\n");

    end:
    printf("The end\n");        /* end是一个标号, 输出提示信息 */

    return 0;
}
```

### 2.1.2 使用goto语句进行出错处理

在C语言中经常使用goto语句做出错处理。在编写程序的过程中经常需要使用系统调用，在调用这些系统调用的过程中难免会出现错误。例如需要打开的文件不存在、分配内存失败等。

如果一个系统调用出现错误，这时程序就很难执行下去了，往往需要退出程序。

在退出程序时需要释放一些资源，这些释放资源的操作通常被集中在一起，当程序出错时直接跳转到出错处理的代码处执行，释放之前分配的资源。


下面的实例演示了一个将文件中的小写字符转换为大写字符输出的程序。该程序定义了一个函数进行这种转换操作。首先调用fopen()函数打开文件，之后调用malloc()函数为文件内容分配缓冲区，再将其文件内容读入到缓冲区中。

这3个过程中均有出错的可能。

因此在出错退出时需要关闭已经打开的文件，并且释放已经分配的内存。这些操作在函数的结尾进行，定义一个标号作为这些操作的入口，其流程如图所示。

![](图.png)


```c

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int convert(void)
{
    FILE *fp;
    struct stat statbuf; /* 文件状态的存储结构 */
    char *p, *q;

    int n;

    if (stat("file.txt", &statbuf) == -1)
        errRet(-1, "fail to get stat");

    fp = fopen("file.txt", "rb");

    if (fp == NULL)
        errRet(-1, "fail to open");

    p = (char *) malloc(sizeof(char) * (statbuf.st_size + 1));

    /* 动态分配保存文件内容的缓冲区，如果失败需要关闭上一个fopen打开的文件，跳转到errl */
    if (p == NULL) {
        errMsg("fail to malloc");
        goto err1;
    }

    n = fread(p, sizeof(char), statbuf.st_size, fp);
    if (n == -1) { /* 当输出字符数等于-1的时候，程序出错 */
        errMsg("fail to read");
        goto err2;
    }

    *(p + n) = '\0'; /* 设置结束标置 '\0' */

    q = p;
    while (*q != '\0') { /* 处理文件内容，将小写字符转换为大写字符输出 */
        if ('a' >= *q && *q <= 'z')
            *q += 32;
        printf ("%c", *q);
        q++;
    }

    err2:
        free(p); /* 释放动态分配的缓冲区 */
    err1:
        fclose(fp); /* 关闭打开的文件 */

    return 0;
}
```

### 2.1.3 出错处理的一般模型

根据2.1.2节的实例可以总结使用goto语句和标号进行出错处理的一个代码框架。其核心思想是释放资源的顺序和申请资源的顺序相反，每一次释放资源的操作之前定义一个标号，每次系统操作失败后跳转到指定标号处，顺序释放所有的资源，其代码框架如下：

```
系统调用1
    没有资源，直接退出
系统调用2
    失败则跳转到err_1;
...
系统调用n
    失败则跳转到err_n-1;

err_n-1:
    释放系统调用n-1申请的资源
err_n-2:
    释放系统调用n-2申请的资源

return结果
```

这种代码框架的好处是当跳转到某一个标号处的时候会顺序执行。例如，如果系统调用n-l出错，会跳转到err n-2处进行出错处理，因此会顺序释放系统调用n-2、系统调用n-3等等，以及系统调用l所申请的资源，到最后退出函数或者整个程序，其流程图如图2-2所示。

![](图.png)

## 2.2  C语言中的分支结构

分支结构是C语言中最基础的一种结构，也是主要的一种结构，本节将从控制流程的角度介绍分支结构。

### 2.2.1 分支结构的翻译

C语言程序中所有的控制和调转都可以使用goto语句的形式实现。将这些跳转转换为goto语句的形式有利于读者了解其内部的控制流程，加深对C语言的理解。

分支结构是实现一个条件跳转，其基本的实现如下：
```
if (条件表达式)
    执行语句1
else
    执行语句2
```

如果使用描述其控制结构的伪代码，可以更清晰地看到其执行流程。控制结构的伪代码使用goto语句实现，其代码如下：

```
t = 条件表达式的值
if (t的值为真)
    goto true;
else
    goto done;

true:
    执行语句1;
done:
    执行语句2;
```

下面程序演示一个使用if-else分支结构的简单C语言程序，以及一个使用goto语句实现的版本。

程序清单2-3  ifelse.c使用分支结构的程序
```c
#include <stdio.h>

int main(void)
{
    int a,b;
    scanf("%d%d", &a, &b);

    if (a > b)
        printf("a is higher than b\n");
    else
        printf("a is lower than b\n");

    return 0;
}
```
### 2.2.2 使用goto语句实现分支结构

使用goto语句可以实现if-else控制流程，其代码如下。这个流程实际上模拟了内部使用的跳转模式。在汇编语言中跳转就是这样执行的。

(1)在vi编辑器中编辑该程序。
程序清单2-4 ifelse_goto.c使用goto语句实现if-else控制流程

```c
#include <stdio.h>

int main(void)
{
    int a, b, t;
    scanf("%d%d", &a, &b);
    t = a > b;
    if (t == 1)
        goto true;
    printf("a is lower than b\n");  /* 执行else的语句 */
    goto done;                      /* 跳转到程序结束处 */

    true:
        printf("a is higher than b\n"); /* 执行条件满足时的语句 */
    done:

    return 0;
}
```
(2)在shell中编译该程序
```
$gcc ifelse_goto.c -o ifelse_goto
```
(3)在shell中执行该程序
```
7
5
a is higher than b
```

## 2.3 短路计算

C语言中支持3个最基本的逻辑运算符，分别是逻辑与(&&)、逻辑或(||)和逻辑(!)。这3个运算符根据两端的操作数得出两种结果-l或者0。其真值表如表2-1和表2-2所示。

表2-1逻辑与(&&)的真值表
```
┌──────────────────────┬──────────────────────┬────────────────┐
│    &&运算的左操作数  │    &&运算的右操作数  │    &&运算的值  │
├──────────────────────┼──────────────────────┼────────────────┤
│    1                 │    l                 │    1           │
├──────────────────────┼──────────────────────┼────────────────┤
│    1                 │    0                 │    0           │
├──────────────────────┼──────────────────────┼────────────────┤
│    0                 │    1                 │    0           │
├──────────────────────┼──────────────────────┼────────────────┤
│    0                 │    0                 │    0           │
└──────────────────────┴──────────────────────┴────────────────┘
```
表2-2逻辑或(||)的真值表
```
┌──────────────────────┬──────────────────────┬────────────────┐
│    ||运算的左操作数  │    ||运算的右操作数  │    ||运算的值  │
├──────────────────────┼──────────────────────┼────────────────┤
│    1                 │    1                 │    l           │
├──────────────────────┼──────────────────────┼────────────────┤
│    l                 │    0                 │    1           │
├──────────────────────┼──────────────────────┼────────────────┤
│    0                 │    l                 │    1           │
├──────────────────────┼──────────────────────┼────────────────┤
│    0                 │    0                 │    0           │
└──────────────────────┴──────────────────────┴────────────────┘
```

根据真值表，不难看出&&运算和||运算的规律。对于&&运算来讲，如果左右操作数中有一个值为0，则整个逻辑表达式的值为0，例如下面表达式中：

`表达式1 && 表达式2`

如果表达式l的值为0，则不需要计算表达式2的值而可以直接确定整个逻辑表达式的值为0。同样，对于0运算来讲，如果左右表达式的值有一个为l，则整个逻辑表达式的值为1，例如下面表达式中：

`表达式1 || 表达式2`

如果表达式1的值为1，则这时不需要计算表达式2的值就可以直接确定整个逻辑表达式的值为l。这种只需要计算第1个表达式的值就可以确定整个表达式的值的方法称为短路计算。注意的是编译器在为逻辑表达式生成代码时都会采用短路计算。

### 2.3.2 &&运算的短路计算

在机器内部，&&运算的短路计算被翻译成为若干个跳转，其基本形式如下：

```
if（表达式1的值为真, 并且表达式2的值为真, 并且...表达式n的值为真）
    执行语句;
```

使用goto语句可以实现&&运算的短路计算，其代码如下。该短路计算的形式可以参照上面的`if-else`语句的翻译。

```
if（表达式l的值为假）
    goto done;
if（表达式2的值为假）
    goto done;

    ...

if (表达式n的值为假)
    goto done;

执行语句;

done:
    statement;
```

下面示例演示了&&运算的短路计算。该程序判断一个地址中的值是否为100。在获取该地址中的内容之前需要首先判断该地址的值是否为空，程序中的判断充分利用了短路计算的特性。

程序清单2-5 and.c使用短路计算的C语言实例

```c
#include <stdio.h>

int main(void)
{
    int a = 200;
    int *p = NULL;

    p = &a;

    if (p != NULL && *p == 100)
        printf("hello\n");
    else
        printf("hi\n");

    return 0;
}
```

该程序判断指针p是否指向一个确切的整型变量的存储空间，如果p的值为NULL，则不会执行`*p==NULL`这个表达式，因此不用担心当p的值为NULL，在执行后面的语句时是否会造成内存的错误访问。最后总结一下&&运算流程如图所示:

![](图.png)

### 2.3.3 ||运算的短路计算

在机器的内部，||运算的短路计算同样会被翻译成为若干个跳转，其基本形式如下：

```
if (表达式1的值为真, 或者表达式2的值为真, 或者...表达式n的值为真)
    执行语句;
```
使用goto语句可以实现||运算的短路计算，其代码如下所示。

说明：逻辑或的短路计算同逻辑与的短路计算，读者可以参照两个代码进行理解。
```
if (表达式1的值为真)
    goto done;
if (表达式2的值为真)
    goto done;
    ...
if (表达式n的值为真)
    goto done;
goto end;
done:
执行语句;
end:
;
```

下面示例演示了||运算的短路计算。该程序判断一个地址的值是否为空或者该地址内存储的内容是否是200。

注意：在获取其地址内的内容之前，首先判断该指针指向的空间是否为NULL。

```c
#include <stdio.h>

int main(void)
{
    int a = 200;
    int *p = NULL;

    p = &a;

    if (p == NULL || *p != 100)
        printf("hi\n");
    else
        printf("hello\n");

    return 0;
}
```
||运算的短路计算流程图如图所示。

图2-4  ||运算的短路计算流程图

说明：活用短路计算是一种高级的C语言程序设计技巧，一个优秀的C语言软件工程师应当熟悉这种操作。

## 2.4  C语言中的循环结构

C语言中的循环分为3种形式，分别是while循环、do-while循环和for循环。这3种循环在功能上有细微的区别，但共同的特点是实现一个循环，可以使程序反复执行一段代码。本节将分别介绍这3种循环。

### 2.4.1 while循环
while循环基本形式如下：
```
while (条件表达式)
    循环语句;
```
使用goto语句的伪代码实现while循环的结构如下：

```
    t = 条件表达式j;
    if (t的值为假)
        goto done;
loop：
    循环语句;
    t = 条件表达式j;
    if (t的值为真)
        goto loop;
done：
```

下面程序演示一个使用while循环结构的简单C语言程序和一个使用goto语句实现的版本。对比这两个版本的C语言程序，可以理解while循环结构的控制流程。

(1)在vi编辑器中编辑该程序。

程序清单2-7 while.c使用while循环实现计算一个整数的阶乘
```c
#include <stdio.h>
int main (void)
{
    int n;
    int mul = 1;     /* 用于累计各个整数的乘积 */
    int i;
    scanf("%d", &n); /* 输入一个整数n */
    i = 1;
    while (i <= n) { /* 循环计算n的阶乘, 每次将mul乘以循环算子 */
        mul *= j;    /* 累计乘积 */
        i++;
    }
    printf ("the result is %d\n", mul) ;  /* 输出结果 */

    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc while.c -o while
```
(3)在shell中执行该程序。
```
$./while
5    (输入数据n)
the result is 120
```

使用goto语句实现while循环结构流程。

说明：在汇编语言中循环的跳转同样使用类似的方法实现。

(1)在vi编辑器中编辑该程序。

程序清单2-8 while_goto.c使用goto语句实现while循环
```c
#include <stdio.h>
int main (void)
{
    int n;
    int mul = 1;     /* 用于累计各个整数的乘积 */
    int i;
    int t;
    scanf("%d", &n); /* 输入一个整数n */
    i= 1;
    t = i <= n;

    if (t == 0) goto done;

    loop:
    mul *= i;
    i++
    t = i <= n;
    if (t == 1) goto loop;

    done:
    printf("the result is %d\n", mul); /* 输出结果 */
```

(2)在shell中编译该程序。
```
$gcc while_goto.c -o while_goto
```
(3)在shell中执行该程序。
```
10     (输入数据n)
the result is 3628800
```

### 2.4.2 do-while循环
`do-while`循环的功能与while循环类似，不同的是do-while循环需要先执行一次循环语句之后，再进行条件判断是否要继续执行循环语句。因此，使用do-while循环至少要执行一次循环语句。do-while循环的基本形式如下：
```
do
    循环语句;
while (条件表达式);
```

使用goto语句的伪代码实现while循环的结构如下：
```
loop:
    循环语句;
    t = 条件表达式;
    if (t的值为真)
        goto loop;
```
下面程序演示一个使用while循环结构的简单C语言程序，以及一个使用goto语句实现的版本。

说明：对比这两个版本的C语言程序，可以理解while循环结构的控制流程。

(1)在vi编辑器中编辑该程序。
程序清单2-9  do_while.c使用while循环实现计算一个整数的阶乘
```c
#include <stdio.h>

int main(void)
{
    int n;
    int mul = 1;
    int i;
    scanf("%d", &n);
    i = 1;
    do {
        mul *= i;
        i++;
    } while (i <= n);
    printf("the result is %d\n", mul);
    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc do_while.c -o do_while
```
(3)在shell中执行该程序。
```
$./do_while
5
the result is 120
```

使用goto语句实现while循环结构流程。
(1)在vi编辑器中编辑该程序。

程序清单2-10 do_while_goto.c使用goto语句实现while循环
```c
#include <stdio.h>

int main(void)
{
    int n;
    int mul = 1;
    int i;
    scanf("%d", &n);
    i = 1;

    loop:
    mul *= i;
    i++;
    if (i <= n) goto loop;
    printf("the result is %d\n", mul);

    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc do_while_goto.c -o do_while_goto
```
(3)在shell中执行该程序。
```
$./do_while_goto
10
the result is 3628800
```

### 2.4.3 for循环
for循环的基本形式如下：
在机器的内部，for循环被编译器翻译为一个while循环语句。不同的是，在while循环语句之前需要加上对循环算子的初始化。
```
初始循环算子;
while (条件表达式) {
    循环语句;
    递增循环算子;
}
```

使用goto语句的伪代码实现for循环的结构如下：
```
初始化循环算子;
t = 条件表达式的值;
if (t的值为假)
    goto done;

loop:
    循环语句;
    递增循环算子;
    t = 条件表达式的值;
    if (t的值为真)
        goto loop;
done;
```

下面程序演示一个使用for循环结构的简单C语言程序，以及一个使用goto语句实现的版本。
说明：对比这两个版本的C语言程序，可以理解for循环结构的控制流程。

(1)在vi编辑器中编辑该程序。
程序清单2-11  for.c使用for循环实现由1到n的n个数的和
```c
#include <stdio.h>
int main(void)
{
    int n;
    int add = 0; /* 累计加法的结果 */
    int i;
    scanf("%d", &n); /* 输入一个整数n */
    for (i = 1; i <= 10; i++) /* 循环算子初始化, 条件判断和循环算子递增 */
        add += i; /* 累计和 */

    printf ("the result is %d\n", add);

    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc for.c -o for
```
(3)在shell中执行该程序。
```
$./for
10
the result is 55
```

使用goto语句实现for循环结构流程。

(1)在vi编辑器中编辑该程序。

程序清单2-12 for_goto.c使用goto语句实现for循环
```c
#include <stdio.h>
int main(void)
{
    int n;
    int add = 0;
    int i;
    int t;
    scanf("%d", &n);
    i = 1;
    t = i <= n;
    if (t == 0) goto done;

    loop:
    add += i;
    i++;
    t = i <= n;
    if (t == 1) goto loop;

    done:
    printf("the result is %d\n", add);
    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc for_goto.c -o for_goto
```
(3)在shell中执行该程序。
```
$./for_goto
20
the result is 210
```
说明：通过观察可以发现，for循环的goto语句版本的代码和while循环的goto语句版本的代码几乎一样。也就是说，这两种循环的控制结构是一样的。

由此可知，在机器内部for循环和while循环是等效的，二者之间可以互相替换。

## 2.5 switch语句
switch语句作为分支结构中的一种，使用方式和if-else语句不尽相同。本节将主要介绍switch语句。

### 2.5.1  switch语句的应用

switch语句是分支结构中的一种。这种特殊的分支语句的作用也是实现程序的条件跳转，不同的是其执行效率比if-else语句实现的分支快很多。原因在于switch语句使用跳转表实现分支，而不是使用依次比较每一个条件的方法。

下面实例演示了一个使用switch语句的C语言程序。该程序输入一个分数，由程序自动判断输出该成绩酌评级。

说明：本程序使用switch语句实现。
(1)在vi编辑器中编辑该程序。
程序清单2-13  switch.c使用switch语句的C语言程序
```c
#include <stdio.h>
int main(void)
{
    char score;
    scanf("%c", &score); /* 输入分数 */
    switch (score) {
        case 'A' : printf("excellent\n"); break; /* 注意, 这个break语句是必须加上的 */
        case 'B' : printf("good\n"); break;
        case 'C' : printf("pass\n"); break;
        default  : printf("fail\n"); /* 默认的提示信息 */
    }
    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc switch.c -o switch
```
(3)在shell中执行该程序。
```
$./switch
A
excellent
```

### 2.5.2  使用goto语句实现switch语句

2.5.1节中的程序所对应的goto语句版本的程序如下所示。

注意：下面代码只是一个伪代码，不能被编译执行。

程序清单2-14 switch_goto.c使用goto语句的形式实现switch语句
```c
#include <stdio.h>

/* 注意该代码不能编译执行, 这里只是说明switch结构使用的跳转表的原理 */
int main(void)
{
    /* 跳转表数组, 这一行代码在C语言是非法的 */
    code * lab[] = {lab_a, lab_b, lab_c};

    char score;
    scanf("%d", &score);

    if (score > 'C') goto lab_default; /* 如果score大于最大的一个标号的值, 直接跳转到默认的语句处执行 */

    score -= 'A'; /* score减去A的值为目的标号在跳转表数组中的下标 */

    goto lab[score]; /* 实现跳转 */

    /* 下面是每一个标号的处理, 处理之后跳转到标号done处执行return语句 */

    lab_a:
    printf ("excellent\n");
    goto done;

    lab_b:
    printf ("good\n");
    goto done;

    lab_c:
    printf ("pass\n");
    goto doen;

    lab_default:
    printf ("fail\n");

    done:
    return 0;
}
```

根据实现switch语句的goto语句版本的程序可知，switch语句执行每一个标号只需要一次比较和一次跳转即可找到需要执行的语句。而if-else语句则需要多次比较才可以定位到需要执行的语句，二者的区别如图2-5所示。

说明：由此可知，在时间方面，switch语句的执行速度比if-else语句要快，但是在程序执行所占用的空间方面，switch语句需要维护一张跳转表。

这个跳转表的本质是一个标号的数组，因此switch语句需要额外的存储空间，在空间效率上if-else语句要高一些。switch语句可以说是一个空间换时间的典型例子。

跳转表的基地址case语句后面的常虽表示目的地址存储在跳转表中的下标
图2-5  switch语句形成的跳转表示意

## 2.6优化控制结构

一个好的控制结构对程序执行效率的影响是巨大的，因此，对控制结构的优化非常重要。本节将详细介绍控制结构的优化问题。

### 2.6.1  表达式优化——使用替换程序中的乘除法

表达式的优化是最基本的优化，使用简洁高效的表达式可以大幅度提高程序的效率。优化是一个广泛而深入的话题，在这里笔者并不深入讲解优化操作的方方面面，只是举一些实例，使读者可以根据实例切身感觉到优化程序的作用。

在程序执行过程中，加减法操作是计算机最喜欢的操作。其执行时间只占用1个时钟周期，是最快速的操作。位运算与移位操作的执行速度和加减法接近。乘法的执行时间要长一些，大概在5个时钟周期至6个时钟周期内完成。除法的执行速度最慢，大约需要50个时钟周期才能完成一个除法操作。这些指令操作所需要的时间如图2-6所示。

图2-6计算机中的指令执行时间

因此在编写裎序时应该使用一些操作代替乘除法的操作。

说明：移位操作是一个很好的选择，数据左移一位相当于乘以2，右移一位相当于除以2，使用移位操作可以将整数的乘除法转换为对整数的移位操作。


下面实例演示了这种替换。该程序将所有的乘法使用移位操作替换，这样可以提高程序的运行效率。

(1)在vi编辑器中编辑该程序。
程序清单2-15  shift.c使用移位操作代替程序中的乘除法运算
```c
#include <stdio.h>
int main (void)
{
    int a = 12;
    printf ("a divided by 4: %d＼n", a>>2);        /* 使用右移操作代替除法 */
    printf("a multiplied by 5: %d＼n", (a<<2) +a); /* 使用左移操作代替乘法 */
    return 0;
}
```

(2)在shell中编译该程序。
```
$gcc shift.c -o shift
```
(3)在shell中执行该程序。
```
$./shift
a divided by 4 : 3
a multiplied by 5 : 60
```
说明：由于移位指令的执行速度和加减法差不多，因此替换之后的程序执行速度也会快很多。

对于乘法来讲，所有的乘法操作均可以由左移运算来替换，例如，a*8可以替换为a<<3，而a*13可以替换为(a<<3)+(a<<2)+a。但是除法操作却不可以。只有除法操作中的除数正好是一个2的n次幂时才能使用右移操作替换除法运算，例如，a/8可以替换力a>>3，但是a/ 13则无能为力。

### 2.6.2表达式优化——常量折叠

在进行计算的过程中，通常需要进行连续的四则运算，如下所示。
```c
int a = 10;
a = a + 2 * 17 + 6;
```
这个程序实际上等同于以下形式：
```c
int a;
a = a + 40;
```
如果写成这种形式，该程序实际上只需要执行1次计算，计算a+40的值。但是如果将其写为"a+2*17+6"的形式，则需要进行2次加法运算和1次乘法运算。哪个代码的执行速度更快便一目了然了。这种将程序中的常量人为计算的方法叫做常量折叠。

说明：这种方法可以提高程序的执行速度。

对于现代的编译器来讲，常量折叠已经是一种常规的优化方式。也就是说，即使自人员在编程过程中没有将常量折叠，编译器也会代劳执行。因此，有些时候在源程序c使用常量折叠的效果可能会更好一些，代码更利于理解和维护。

### 2.6.3表达式优化——使用数学公式

计算机的特点是准确地执行重复性的工作。利用这个特点用户可以将大量的计算工作交给计算机去做。使用计算机解决问题时，诸如枚举、递归等人们想起来就头疼的解题方法成了计算机计算的一般性做法。这些方法实现简单，对于计算机来讲，这些重复性的工作完全可以保证准确性，而且计算机是不会感到疲倦和厌烦的。

下面实例是一个使用循环的例子，该程序计算1~n之间n个整数的和时，可以简单地使用一个循环，每次累加循环算子即可。

(1)在vi编辑器中编辑该程序。
程序清单2-16  sum.c计算1~n之间所有整数的和
```c
#include <stdio.h>
int main(void)
{
    int i, n, sum = 0;
    scanf("%d", &n); 

    for (i = 1; i <= n; i++) /* 使用一个循环计算1到n之间所有的整数的值 */
        sum += i;

    printf("the result is:%d\n", sum);
    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc sum.c -o sum
```
(3)在shell中执行该程序。
```
$./sum
100
the result is:5050
```
这个程序执行100次循环，每次需要做的计算如下。
    1.判断条件，是否需要继续执行循环。
    2.累加循环算子i。
    3.累如保存和的变量sum。

因此该程序需要执行300次计算，才能得出正确的结果。现在将该程序修改一下，用数学公式——著名的高斯定理来实现该程序。

(1)在vi编辑器中编辑该程序。
程序清单2-17  sum_fast.c计算1~n之间所有整数的和
```c
#include <stdio.h>
int main(void)
{
    int i,n,sum=0;
    scanf("%d", &n);
    sum = ((1 + n) * n) / 2; /* 使用高斯公式计算1到n之间所有整数的和 */
    printf("the result is:%d\n", sum);

    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc sum_fast.c -o sum_fast
```
(3)在shell中执行该程序。
```
$./sum
100
the result is:5050
```
上面程序同样实现了计算1至n之间所有整数的和，但是改进版的程序只要执行三次运算，首先计算n+l的值。接着计算(n+1)奉n的值。最后计算((n+1)*n)/2的值。和第一个程序比起来，执行效率的提升是显著的。因此，在编写程序的过程中应用数学公式，可以起到大幅度提高程序执行效率的作用。

### 2.6.4表达式优化——存储问题

C语言中的变量需要保存在内存中，相对于CPU内部的寄存器操作，访问内存所消耗的时间是很大的。因此减少内存访问也是提高程序运行效率的方法之一。

例如，对于内存的访问导致下面两个语句的执行速度不同，但这两个语句实现同样的功能。
```
语句1 x = x + 1;
```

该语句在执行过程中编译器会认为赋值符号"="两边的操作数不是一个操作数，而是两个。尽管用户知道这两个变量实际上是一个。这时该语句的执行过程分为三步，分别是：寻找存储左边操作数x的内存单元的地址；寻找存储右边操作数x酌内存单元的地址；计算x+l的值并且存储在变量x中，其执行流程如图2-7所示。

```
语句2 x += 1;
```
该语句在执行过程中编译器会认为赋值符号"="两边的操作数是同一个操作数。所以该语句的执行过程分为两步，分别是：寻找存储操作数x的内存单元的地址；计算x+1的值并且存储在变量x中，其执行流程如图2-8所示。

### 2.6.5  分支优化——改变判断顺序

if-else语句可以进行条件判断，从而使程序产生分支。但是if-else语句中的条件判断的安排顺序也是有讲究的。 

注意：有时刻意地更改条件判断的顺序，可以大幅度提高程序的运行效率。

下面实例演示了统计一篇英文文章中的字母数、数字数和空格数。该程序打开一篇英
文文章的文本文件，将其内容读入缓冲区中，之后累加字母数、数字数和空格数即可。

当程序将文件内容读入内存中后，开始处理文件的内容。其中处理一行内容的操作是一个循环，如图2-9所示。

图2-9统计英文文章中分类字符的流程图

该程序有两个版本，其区别在于使用了不同的条件判断程序执行顺序，其流程图如图2-10所示。

图2-10统计英文文章中各类字符的程序流程图

根据流程图，可以编写如下代码。

程序清单2-18 slow.c使用条件分支结构统计字符
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX 1024

int main(void)
{
    FILE *fp;
    char buf[MAX]; /* 存储文件内容的缓冲区 */

    int n;
    int letter = 0, blank = 0, number = 0;

    fp = fopen ("article.txt", "r");
    if (fp == NULL) {
        perror("fail to open");
        exit(1);
    }

    while ((n = fread(buf, sizeof(char), MAX, fp)) > 0) {
        int i;
        for (i = 0; i < n; i++) { /* 遍历已经读入的内容, 对每个字符进行判断 */
            if (buf[i] >= '0' && buf[i] <= '9') number ++; /* 数字 */
            else if (buf[i] == ' ') blank++; /* 空格 */
            else if ((buf[i] >= 'a' && buf[i] <= 'z') || (buf[i] >= 'A' && buf[i] <= 'Z')) letter++; /* 字母 */
        }
    }
    printf ("letter %d, number %d, blank %d\n", letter, number, blank);
    fclose(fp);
    return 0;
}
```

该程序对文章内容进行判断时，首先判断当前字符是否是数字，之后再判断当前字符是否是空格，最后才判断当前字符是否是字母。这个判断顺序是不合适的。因为在一篇英文文章中出现概率最大的字符是字母，其次是空格（英文使用空格将单词隔开），最后才是数字。

该程序的判断顺序导致的后果是：对文章中大部分的字符需要经过3次判断才能得到正确的累加值。这个判断效率裉低，改进的实现方法如下面代码所示。

程序清单2-19  fast.c使用条件分支结构统计字符
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX 1024

int main(void)
{
    FILE *fp;
    char buf[MAX]; /* 存储文件内容的缓冲区 */

    int n;
    int letter = 0, blank = 0, number = 0;

    fp = fopen ("article.txt", "r");
    if (fp == NULL) {
        perror("fail to open");
        exit(1);
    }

    while ((n = fread(buf, sizeof(char), MAX, fp)) > 0) {
        int i;
        for (i = 0; i < n; i++) { /* 遍历已经读入的内容, 对每个字符进行判断 */

            /* 这个判断的顺序更符合实际规律 */

            if ((buf[i] >= 'a' && buf[i] <= 'z') || (buf[i] >= 'A' && buf[i] <= 'Z')) letter++; /* 先判断是否是字母 */
            else if (buf[i] == ' ') blank++; /* 再判断是否是空格 */
            else if (buf[i] >= '0' && buf[i] <= '9') number++; /* 最后判断是否是数字 */
        }
    }
    printf ("letter %d, number %d, blank %d\n", letter, number, blank);
    fclose(fp);
    return 0;
}
```
以上两个程序代码的不同点在于第2个代码修改了条件判断的顺序。先判断该字符是否是字母，之后判断该字符是否是空格，最后判断该字符是否是数字。这样，对于文章中出现概率最大的字母字符，只需要一次判断就可以进行正确地累加了，效率的提升是以前的3倍。

### 2.6.6  分支优化——使用switch语句

根据2.6.5节的汇编代码翻译可知，switch语句每次进行条件判断时只需要比较一次，之后使用跳转表实现跳转，而if.. else结构需要比较多次才能实现跳转。

说明：在某些场合下，switch语句比if-else语句的执行效率更高。

下面实例演示了if-else语句结构的使用。该程序接受用户输入的一个字母，输出相应的分数。

程序清单2-20  score.c用户输入的一个字符输出相应的分数
```c
#include <stdio.h>
int main (void)
{
    int score;
    scanf("%d", &score); /* 输入分数 */

    if (score == 'A')       printf("90 ~ 100\n");    /* 分数为A */
    else if (score == 'B')  printf("80 ~ 90\n");     /* 分数为B */
    else if (score == 'c')  printf("70 ~ 80\n");     /* 分数为C */
    else if (score == 'D')  printf("60 ~ 70\n");     /* 分数为D */
    else if (score == 'E')  printf("0 ~ 50\n");      /* 分数为E */
    else                    printf("wrong input\n"); /* 错误输入*/

    return 0;
}
```

如果输入的是D，则需要经过3次比较才能执行输出语句；如果输入的是E，则需要比较4次才能执行输出语句。这对代码效率的浪费是很严重的，使用switch语句可以解决这个问题。switch语句使用跳转表实现跳转，这时无论输入的字符是什么，都只需要进行2次比较就可以执行输出语句了。下面实例使用switch语句实现上面的实例。

程序清单2-21  switch.c用户输入的一个字符输出相应的分数
```c
#include <stdio.h>
int main(void)
{
    int score;
    scanf("%d", &score);
    switch (score) {
        case 'A': printf("90 ~ 100\n"); break;
        case 'B': printf("80 ~ 90\n"); break;
        case 'C': printf("70 ~ 80\n"); break;
        case 'D': printf("60 ~ 70\n"); break;
        case 'E': printf("0  ~ 50\n"); break;
        default:  printf("wrong input\n");
    }

    return 0;
}
```
注意：switch语句也不是万能的，有些场合使用switch语句就无法提高效率。

因为switch语句只能判断是一个指定值的数据，而不能对一个区间中的数据进行判断。

例如，判断a是否在10～20这个区间内时，使用if-else语句代替switch语句是一个明智的选择。

### 2.6.7 循环优化——一次性计算

在循环中有些计算是多次不变的，这种计算称为一次性计算。由于一次性计算在循环执行期间不改变计算的结果，这时在循环外计算该表达式和在循环内执行的效果是一样的。因此对于这种循环中的一次性计算，应当将其放置到循环外面。

下面是一个一次性计算的例子，在循环中每次将len变量赋值为1。该表达式在循环执行10次的值与在循环外执行1次的效果是一样的。

```c
int len; /* 循环外声明变量 */
int a[10];
for(i=0; i<10; i++)
{
    len=1; /* 该循环内len的值是不会改变的 */
    a[i] = i;
}
```

将一次性计算的表达式"len=l;"提出到循环外面执行，这样每次循环可以少执行一次赋值操作，其执行效率会有很大的提高。

```c
int len = 1; /* 将len的赋值提出到循环的外面 */
int a[10];
for (i = 0; i < 10; i++) /* 循环中只剩对数组元素的赋值 */
{
    a[i] = i;
}
```

这种优化的效果有时是很惊人的。下面再列举一个一次性计算的实例，该程序是一个大小写转换程序，使用两个版本实现，一个是没有消除循环中一次性计算的版本，另一个是消除了循环中一次计算的版本。同样功能的两个程序，运行的效率却是天壤之别。

(1)在vi编辑器中编辑该程序。

程序清单2-22  low.c效率低的大小写转换程序
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 1024
void lower1(char *p) /*大小写转换函数*/
{
    int i;
    for(i=0; i < strlen(p); i++) /*将字符串中的大写字母转换成小写字母*/
        if(p[i] >='A' && p[i] <= 'Z')
             p[i] +=32;      /*转换为小写字母*/
    printf("%s",p);
}
int main(void)
{
    FILE *fp;
    char buf[MAX];
    int n;
    fp = fopen("text.txt","r");  /*打开文件*/
    if(fp == NULL){
        perror("fail to open");
        exit(1);
    }
    while((n = fread(buf,sizeof(char),MAX - 1, fp)) > 0){ /*读取一个字符串。直到文件结束*/
         buf[n] = '\0';
         lower1(buf);
    }
    if(n < 0){    /*读入文件出错*/
        perror("fail to read");
        exit(1);
    }

    fclose(fp);

    return 0;
}
```
(2)在shell中编译该程序。
```
$gcc low.c -o low 
```
(3)在shell中运行该程序。
```
$./low
hello world
```

以上代码中lower1函数的判断条件需要计算字符的长度。该函数的调用相当于遍历一遍字符缓冲区，并且计算字符的个数。假设文件很大的情况下，每次读入的内容都可以填满缓冲区，也就是说每次都需要扫描1024个字节，这时程序的执行效率会很低。

^^^^^^说明：由于每次执行循环时字符数组的长度不会变，因此可以将strlen函数的执行提到循环外面，这时程序的执行效率会提高很多。

(1)在vi编辑器中编辑该程序。

程序清单2-23 fast.c效率高的大小写转换程序
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 1024
void lower2(char *p) /*大小写转换函数*/
{
    int i, len;
    len = strlen(p);
    for(i=0; i< len; i++) /*将字符串中的大写字母转换成小写字母*/
        if(p[i] >='A' && p[i] <= 'Z')
             p[i] +=32;      /*转换为小写字母*/
    printf("%s",p);
}
int main(void)
{
    FILE *fp;
    char buf[MAX];
    int n;
    fp = fopen("text.txt","r");  /*打开文件*/
    if(fp == NULL){
        perror("fail to open");
        exit(1);
    }
    while((n = fread(buf,sizeof(char),MAX - 1, fp)) > 0){ /*读取一个字符串。直到文件结束*/
         buf[n] = '\0';
         lower2(buf);
    }
    if(n < 0){    /*读入文件出错*/
        perror("fail to read");
        exit(1);
    }

    fclose(fp);

    return 0;
}
```

(2) 在shell中编译该程序
```
$gcc fast.c -o fast
```
(3) 在shell中运行该程序
```
$./fast
hello world
```